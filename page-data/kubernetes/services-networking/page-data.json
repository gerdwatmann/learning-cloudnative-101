{"componentChunkName":"component---src-pages-kubernetes-services-networking-index-mdx","path":"/kubernetes/services-networking/","result":{"pageContext":{"frontmatter":{"title":"Services & Networking","description":"Services & Networking in Kubernetes"},"relativePagePath":"/kubernetes/services-networking/index.mdx","titleType":"page","MdxNode":{"id":"62a66854-822e-5a26-94c9-5a6027191700","children":[],"parent":"464e1990-aefc-54f1-abec-c12f119645af","internal":{"content":"---\ntitle: Services & Networking\ndescription:  Services & Networking in Kubernetes\n---\n\n<AnchorLinks>\n  <AnchorLink>Services</AnchorLink>\n  <AnchorLink>Ingress</AnchorLink>\n  <AnchorLink>Activities</AnchorLink>\n</AnchorLinks>\n\n# Services\n\nAn abstract way to expose an application running on a set of Pods as a network service.\n\nKubernetes Pods are mortal. They are born and when they die, they are not resurrected. If you use a Deployment to run your app, it can create and destroy Pods dynamically.\n\nEach Pod gets its own IP address, however in a Deployment, the set of Pods running in one moment in time could be different from the set of Pods running that application a moment later.\n\nIn Kubernetes, a Service is an abstraction which defines a logical set of Pods and a policy by which to access them (sometimes this pattern is called a micro-service). The set of Pods targeted by a Service is usually determined by a selector (see below for why you might want a Service without a selector).\n\nIf you’re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes.\n\nFor non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.\n\n\n## Resources\n- https://kubernetes.io/docs/concepts/services-networking/service/\n- https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/\n\n## References\n\n```\nkubectl get svc\nkubectl describe svc my-service\nkubectl get ep my-service\nkubectl get deployments\nkubect get rs\nkubect get pods\nkubectl get all\nkubectl expose deployment my-deployment --port 80 --target-port=http --selector app=nginx --name my-service-2 --type NodePort\nminikube service --url\nkubectl por-forward\n```\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-deployment\n  labels:\n    app: nginx\n    version: v1\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n        version: v1\n    spec:\n      containers:\n      - name: nginx\n        image: bitnami/nginx\n        ports:\n        - containerPort: 8080\n          name: http\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app: nginx\n  ports:\n    - name: http\n      port: 80\n      targetPort: http\n```\n\n# Ingress\n\nAn API object that manages external access to the services in a cluster, typically HTTP.\n\nIngress can provide load balancing, SSL termination and name-based virtual hosting.\n\nIngress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource.\n\n## Resources\n- https://kubernetes.io/docs/concepts/services-networking/ingress/\n- https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/\n- https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/\n\n## References\n\n```\nminikube addons enable ingress\nkubectl get pods -n kube-system | grep ingress\nkubectl run web --image=bitnami/nginx --port=8080\nkubectl expose deployment web --target-port=8080 --type=NodePort\nkubectl get svc web\nminikube service --url web\n```\n\n```\nstern ingress -n kube-system\nkubectl get ingress\nkubcetl describe ingress example-ingress\ncurl hello-world.info --resolve hello-world.info:80:<ADDRESS>\n```\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /$1\n```yaml\napiVersion: networking.k8s.io/v1beta1 # for versions before 1.14 use extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: example-ingress\nspec:\n  rules:\n  - host: hello-world.info\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: web\n          servicePort: 8080\n```\n\n\n## Activities\n\n| Task                            | Description         | Link        |\n| --------------------------------| ------------------  |:----------- |\n| *** Try It Yourself ***                         |         |         | \n| Creating Services | Create two services with certain requirements. | [Setting up Services](../activities/labs/lab8) |","type":"Mdx","contentDigest":"838a374224ddce6dc4f14a6749790c68","counter":275,"owner":"gatsby-plugin-mdx"},"frontmatter":{"title":"Services & Networking","description":"Services & Networking in Kubernetes"},"exports":{},"rawBody":"---\ntitle: Services & Networking\ndescription:  Services & Networking in Kubernetes\n---\n\n<AnchorLinks>\n  <AnchorLink>Services</AnchorLink>\n  <AnchorLink>Ingress</AnchorLink>\n  <AnchorLink>Activities</AnchorLink>\n</AnchorLinks>\n\n# Services\n\nAn abstract way to expose an application running on a set of Pods as a network service.\n\nKubernetes Pods are mortal. They are born and when they die, they are not resurrected. If you use a Deployment to run your app, it can create and destroy Pods dynamically.\n\nEach Pod gets its own IP address, however in a Deployment, the set of Pods running in one moment in time could be different from the set of Pods running that application a moment later.\n\nIn Kubernetes, a Service is an abstraction which defines a logical set of Pods and a policy by which to access them (sometimes this pattern is called a micro-service). The set of Pods targeted by a Service is usually determined by a selector (see below for why you might want a Service without a selector).\n\nIf you’re able to use Kubernetes APIs for service discovery in your application, you can query the API server for Endpoints, that get updated whenever the set of Pods in a Service changes.\n\nFor non-native applications, Kubernetes offers ways to place a network port or load balancer in between your application and the backend Pods.\n\n\n## Resources\n- https://kubernetes.io/docs/concepts/services-networking/service/\n- https://kubernetes.io/docs/tutorials/kubernetes-basics/expose/expose-intro/\n\n## References\n\n```\nkubectl get svc\nkubectl describe svc my-service\nkubectl get ep my-service\nkubectl get deployments\nkubect get rs\nkubect get pods\nkubectl get all\nkubectl expose deployment my-deployment --port 80 --target-port=http --selector app=nginx --name my-service-2 --type NodePort\nminikube service --url\nkubectl por-forward\n```\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-deployment\n  labels:\n    app: nginx\n    version: v1\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n        version: v1\n    spec:\n      containers:\n      - name: nginx\n        image: bitnami/nginx\n        ports:\n        - containerPort: 8080\n          name: http\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: my-service\nspec:\n  selector:\n    app: nginx\n  ports:\n    - name: http\n      port: 80\n      targetPort: http\n```\n\n# Ingress\n\nAn API object that manages external access to the services in a cluster, typically HTTP.\n\nIngress can provide load balancing, SSL termination and name-based virtual hosting.\n\nIngress exposes HTTP and HTTPS routes from outside the cluster to services within the cluster. Traffic routing is controlled by rules defined on the Ingress resource.\n\n## Resources\n- https://kubernetes.io/docs/concepts/services-networking/ingress/\n- https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/\n- https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/\n\n## References\n\n```\nminikube addons enable ingress\nkubectl get pods -n kube-system | grep ingress\nkubectl run web --image=bitnami/nginx --port=8080\nkubectl expose deployment web --target-port=8080 --type=NodePort\nkubectl get svc web\nminikube service --url web\n```\n\n```\nstern ingress -n kube-system\nkubectl get ingress\nkubcetl describe ingress example-ingress\ncurl hello-world.info --resolve hello-world.info:80:<ADDRESS>\n```\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /$1\n```yaml\napiVersion: networking.k8s.io/v1beta1 # for versions before 1.14 use extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: example-ingress\nspec:\n  rules:\n  - host: hello-world.info\n    http:\n      paths:\n      - path: /\n        backend:\n          serviceName: web\n          servicePort: 8080\n```\n\n\n## Activities\n\n| Task                            | Description         | Link        |\n| --------------------------------| ------------------  |:----------- |\n| *** Try It Yourself ***                         |         |         | \n| Creating Services | Create two services with certain requirements. | [Setting up Services](../activities/labs/lab8) |","fileAbsolutePath":"/home/travis/build/ibm-cloud-architecture/learning-cloudnative-101/src/pages/kubernetes/services-networking/index.mdx"}}}}